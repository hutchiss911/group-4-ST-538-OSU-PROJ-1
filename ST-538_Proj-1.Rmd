---
title: "Data Wizards (Group 4) Project 1"
author:
- Di Chen
- Mai Castellano
- Tyler Kussee
- Spencer Hutchison
output: pdf_document
---

```{r echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
## For your notes, an if statement for checking if a package is installed :)
#if(!require(somepackage)){
#    install.packages("somepackage")
#    library(somepackage)
#}

if (!require(tidycensus)) {
  install.packages("tidycensus")
}
if (!require(tidyverse)) {
  install.packages("tidyverse")
}
if (!require(dplyr)) {
  install.packages("dplyr")
}
if (!require(ggplot2)) {
  install.packages("ggplot2")
}
if (!require(faraway)) {
  install.packages("faraway")
}
if (!require(car)) {
  install.packages("car")
}
if (!require(gridExtra)) {
  install.packages("gridExtra")
}
if (!require(glmnet)) {
  install.packages("glmnet")
}
if (!require(ISLR2)) {
  install.packages("ISLR2")
}
if (!require(leaps)) {
  install.packages("leaps")
}

```


```{r echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
#Load libraries
library(tidycensus)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(faraway)
library(car)
library(gridExtra)
library(glmnet)
library(ISLR2)
library(leaps)

census_api_key("2547c95ce33b1ed0eec3aafd0fd8526a5bb9a22e")
```

# Introduction

The American Community Survey offers crucial insights about our country and its citizens 
each year. The data from this survey plays a pivotal role in guiding the allocation of
trillions of dollars in federal funding, ensuring that resources are directed where 
they are needed most.

With the data from the American Community Survey, the Data Wizards have come up 
with the following 3 questions they would like to answer:

* Does higher education mean higher income accounting for sex and age?
* Can we predict household income based on education, occupation, and race/ethnicity?
* Is there a relationship between race/ethnicity and home ownership?

# Obtain the Data

In the case of the ACS dataset, we'll pull it via an API. We've already declared our key earlier, so now we just need to pull our dataset with the variables and filtering we'd like. In this case we'll want to pull our Age (AGEP), Education Level (SCHL), sex (SEX), and Total Person's Income (PINCP) while filtering to the year 2022 and the State of OR.

```{r echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
#Pull data set for specific variables
puma_data <- get_pums(variables = c("AGEP","SCHL","PINCP", "SEX", "RAC1P", "TEN", "OCCP", "MAR", "ACR")
                      ,state = "OR"
                      ,year = 2022)
```

# Scrub the data

In the data cleaning process, we began by assigning more descriptive column names to enhance clarity. Columns such as "ST", "Serial Number", and "housing weight" were removed as they were deemed unnecessary for our analysis, while "PersonNumber" was retained for potential future use. Subsequently, we converted instances of "bb" in the Education level, "bbbb"/"000N" in the Occupation, and "b" in Homeownership columns to 0, followed by transformation of all 3 columns into numeric values. 

Groupings were then created based on education levels, ranging from "No Education" to "Doctoral Degree". Additional groupings were generated based on Occupation values, resulting in specific industries/positions to get classified. The column order was rearranged for better organization. 

As our focus is on income, individuals under the age of 14 were excluded from the dataset, aligning with Oregon's legal working age. Variable codes were converted to their corresponding descriptions, starting with Education Level. Lastly, we identified the genders present in the dataset to facilitate further analysis. This systematic approach ensures that the data is cleaned and structured appropriately for subsequent analysis.

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Rename the columns
puma_data <- puma_data %>% dplyr::rename(Age = AGEP,
                                  EducationLevel = SCHL,
                                  Income = PINCP,
                                  Sex = SEX,
                                  PersonNumber = SPORDER,
                                  Race = RAC1P,
                                  Homeownership = TEN,
                                  Occupation = OCCP,
                                  MaritalStatus = MAR,
                                  HouseAcreage = ACR
                                  )
head(puma_data[, 2:8])
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Remove columns that are not needed
puma_data <- puma_data %>% 
  select(-ST, -SERIALNO, -WGTP, -PWGTP)
head(puma_data)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Convert education levels
puma_data <- puma_data %>%
  mutate(
    EducationLevel = case_when(
      EducationLevel == "bb" ~ "00",
      TRUE ~ EducationLevel
    ),
    EducationLevel = as.numeric(EducationLevel)
  )

#Make sure it is numeric
class(puma_data$EducationLevel)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Convert Occupation to numerical
puma_data <- puma_data %>%
  mutate(
    Occupation = case_when(
      Occupation == "bbbb" ~ "0000",
      Occupation == "000N" ~ "0000",
      TRUE ~ Occupation
    ),
    Occupation = as.numeric(Occupation)
  )

#Make sure it is numeric
class(puma_data$Occupation)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Convert homeownership
puma_data <- puma_data %>%
  mutate(
    Homeownership = case_when(
      Homeownership == "b" ~ "0",
      TRUE ~ Homeownership
    ),
    Homeownership = as.numeric(Homeownership)
  )

#Make sure it is numeric
class(puma_data$Homeownership)
```

```{r error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Convert HouseAcreage
puma_data <- puma_data %>%
  mutate(
    HouseAcreage = case_when(
      HouseAcreage == "b" ~ "0",
      TRUE ~ HouseAcreage
    ),
    HouseAcreage = as.numeric(HouseAcreage)
  )

#Make sure it is numeric
class(puma_data$HouseAcreage)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
##Group education level
puma_data <- puma_data %>%
  mutate(
     EducationGroup = cut(EducationLevel, breaks = c(0, 16, 21, 22, Inf),
                         labels = c("Less than HS", "HS, GED, or Associates Degree",
                                    "Bachelors Degree", "Masters Degree or higher"),
                         right = FALSE)
  )
unique(puma_data$EducationGroup)
puma_data[1:50,]
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Drop age below 14
puma_data <- puma_data %>%
  filter(Age >= 14)
head(puma_data[puma_data$Age < 14,])


#Drop income that are less than 1 from the data set
#Drop observation with 0 and negative income
puma_data <- puma_data %>% filter(Income >= 1)
head(puma_data)
sum(puma_data$Income<1)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#relabeling race
puma_data$Race <- as.numeric(puma_data$Race)

puma_data <- puma_data %>%
  mutate(
    Race = case_when(
      Race == 1 ~ "White",
      Race == 2 ~ "Black/AfricanAmerican",
      between(as.numeric(Race), 3, 6) ~ "NativeAmerican/Alaskan",
      between(as.numeric(Race), 6, 7) ~ "Asian/PacificIslander",
      between(as.numeric(Race), 8, 9) ~ "Other/MoreThanOne",
      TRUE ~ as.character(Race)
    )
)
puma_data$Race[1:100]
```

```{r error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#relabeling MaritalStatus
puma_data <- puma_data %>%
  mutate(
    MaritalStatus = case_when(
      MaritalStatus == "1" ~ "Married",
      MaritalStatus == "2" ~ "Widowed",
      MaritalStatus == "3" ~ "Divorced",
      MaritalStatus == "4" ~ "Separated",
      MaritalStatus == "5" ~ "Not Married/Under 15",
      TRUE ~ as.character(MaritalStatus)
    )
)

#Checking labels are assigned.
unique(puma_data$MaritalStatus)
puma_data$MaritalStatus[11200:11300]
```

```{r error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#relabeling Acreage
puma_data <- puma_data %>%
  mutate(
    HouseAcreage = case_when(
      HouseAcreage == 0 ~ "Not a one-family home",
      HouseAcreage == 1 ~ "< 1 Acre",
      HouseAcreage == 2 ~ "1 - 10 Acres",
      HouseAcreage == 3 ~ "> 10 Acres",
      TRUE ~ as.character(HouseAcreage)
    )
)

#Checking labels are assigned.
unique(puma_data$HouseAcreage)
puma_data$HouseAcreage[1500:1600]
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#relabeling tenure
puma_data <- puma_data %>%
  mutate(
    Homeownership = case_when(
      Homeownership == 0 ~ "N/A",
      Homeownership == 1 ~ "Owned with mortgage or loan",
      Homeownership == 2 ~ "Owned free and clear",
      Homeownership == 3 ~ "Rented",
      Homeownership == 4 ~ "Occupied without payment of rent",
      TRUE ~ as.character(Homeownership)
    )
)

#Checking labels are assigned.
unique(puma_data$Homeownership)
puma_data$Homeownership[11200:11300]
```


```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Identify gender
puma_data <- puma_data %>%
  mutate(
    Sex = case_when(
      Sex == 1 ~ "Male",
      Sex == 2 ~ "Female",
      TRUE ~ as.character(Sex)
    )
)

#Checking labels are assigned.
unique(puma_data$Sex)
head(puma_data$Sex)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Occupation Grouping
puma_data <- puma_data %>%
  filter(as.numeric(Occupation) >= 0010 & as.numeric(Occupation) < 9920) %>%
  mutate(
    OccupationGroup = case_when(
      between(as.numeric(Occupation), 0010, 3550) ~ "Professional/Technical",
      between(as.numeric(Occupation), 3600, 4160) ~ "Healthcare/FoodServices",
      between(as.numeric(Occupation), 4200, 7640) ~ "WhiteCollar/BlueCollar",
      between(as.numeric(Occupation), 7700, 9760) ~ "Manufacturing/Transportation",
      between(as.numeric(Occupation), 9800, 9830) ~ "Military",
      TRUE ~ "Not Classified"
    )
  )

#Checking labels are assigned.
unique(puma_data$OccupationGroup)
puma_data$OccupationGroup[2020:2120]
puma_data$Occupation[puma_data$OccupationGroup == "Not Classified"]
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
puma_data_raw <- puma_data
head(puma_data_raw)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Rearrange the columns
puma_data <- puma_data %>%
  select(EducationGroup, EducationLevel, OccupationGroup, Occupation, Income, Age, Sex, Race, Homeownership, PersonNumber)
head(puma_data)
```


With the data cleaned up, we can now explore the data.

# Explore the data

We want to get a sense for the data that we'll be working with so first we'll find the range of ages that we have in our dataset. This shows that our mean and median age is very close together (50.99 and 51 respectively) showing a good distribution of ages; with a max age of 95. Education level has a similar mean and median (16.31, and 18 respectively), and it gives us a good way to  picture our distribution as well.  Unlike our age distribution the income mean and median are a bit off (50,432 and 33,700 respectively). This is something we may need to look into more in a graphical view. We also review a table of the levels of education and the their counts.

For Homeownership the the distribution is very interesting with 68% of the sample owning a home either free and clear or though a mortgage. Renters make up a quarter of the sample and the rest may be cleaned up in later sections of the report. As for race 82% of this sample are White alone. The next three largest categories are Two Or More Races, Asian alone, and Some other race alone. This will make for some more difficult predictions.

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Summarizing the ranges of numerical 
summary(puma_data$Age) #Range of Age
summary(puma_data$Income) #Range of Age
summary(puma_data$EducationLevel) #Range of Education
table(puma_data$EducationGroup) #Count of each level of education
table(puma_data$Race) #Count of each race
table(puma_data$Homeownership) #Count of each Homeownership
table(puma_data$OccupationGroup) #Count of each Occupationgroup
```

Next we'll take a look into the income distribution in a graphical view. For this view we will also remove those that are below 0. This allows us to see a very long tailed view of the income distribution for our dataset. Our mean being the tallest point in the graph being around that $21,000 we saw in our exploration. Related to this is the variable occupation groups. These are a little difficult to decipher because there are three categories that are very general that take up 31% of the total working population and those are Management, Office/Admin and Sales. These are broad groups, but hopefully with the other categories and variables we will be able to create a model that will effectively utilize these occupation groups.

```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
#Plot income distribution
ggplot(puma_data %>% filter(Income > 0), aes(Income)) +
  geom_histogram(binwidth = 10000) +
  scale_x_continuous(labels = function(x) paste0(x / 1000, "K")) +
  labs(title = "Income Distribution in Oregon"
       , x = "Income by $10k"
       , y = "Count of Individuals") +
  theme_minimal()
```

[Reference on Variables for now](https://usa.ipums.org/usa/resources/codebooks/DataDict1822.pdf)

# Model the data

We compared two regression models: the first model included EducationGroup, Sex, and Age as explanatory variables, while the second model extended to incorporate an interaction between Sex and Age. ANOVA comparisons between the full and nested models provided compelling evidence that the latter, which accounted for the interaction term, was a better fit (Analysis of variance, p < 0.00001). However, subsequent examination of model diagnostics revealed a violation of the linearity assumption. To address this issue, we transformed the response variable using a logarithmic function.

Upon visualizing the model diagnostics, we observed that, while the plot of fitted values versus residuals generally centered around zero, there was a change in clustering pattern around a certain fitted value and QQ plot shows deviation from normality. Furthermore, Cook's distance indicated the presence of outliers, which were subsequently identified as influential. By fitting another model without these influential observations, we observed an improvement in the regression model, with the adjusted R-squared increasing from 0.1758 to 0.2313, while the coefficients remained significant. Additionally, the model without outliers demonstrated improved normality, as evidenced by the normal QQ plot. The residual versus fitted plot displayed a cloud of observations with a constant gap between each cluster, though they were symmetrically distributed around the y=0 line. Therefore, the assumptions of linearity, constant variance, and normality were satisfied.

Further examination of the Variance Inflation Factor (VIF) values revealed multicollinearity issues, particularly with the Sex and Sex:Age variables, which exhibited VIF values of 8.46 and 9.14, respectively. To address this, we employed Ridge regression to fit the model. Using 10-fold cross-validation, we determined the optimal lambda value to be $\lambda=0.04258514$. The resulting regression model is provided below:

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
# Does higher education mean higher income accounting for sex and age?
model_1 <- lm(Income ~ EducationGroup + Sex + Age, data = puma_data)
model_2 <- lm(Income ~ EducationGroup + Sex * Age, data = puma_data)

#Compare model 1 and 2
anova(model_1, model_2)

#The full model provides a significantly better fit.
```



```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
#Linearity and Homoscedasticity assumption
plot(fitted(model_2), residuals(model_2))

#Normality assumption
qqnorm(residuals(model_2))
qqline(residuals(model_2))

#Independence assumptions
plot(residuals(model_2))

#Fitted vs residuals plot exhibiting pattern
```


```{r,  message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
#Logged models
model_3 <- lm(log(Income) ~ EducationGroup + Sex + Age, data = puma_data, na.action = na.exclude)
model_4 <- lm(log(Income) ~ EducationGroup + Sex * Age, data = puma_data, na.action = na.exclude)

#Compare models 3 and 4
anova(model_3, model_4)

#Model 4 is the best from 2 models
```
```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
#Linear regression assumption
plot(fitted(model_4), residuals(model_4))

#Normality assumption
qqnorm(residuals(model_4))
qqline(residuals(model_4))

#Independence assumptions
plot(residuals(model_4))
```

```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
#Add observation ID
puma_data$ID <- 1:nrow(puma_data)

## Attaching the Case Influence Statistics with the Data
Data <- fortify(model_4, puma_data)

## Plot the Case Influence Statistics for each observation (subject)
par(mfrow=c(1,3))
qplot(ID,.hat, data = Data)
qplot(ID,.stdresid, data = Data)
qplot(ID,.cooksd, data = Data)

#There is evidence of outliers
```


```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE}
#Test for influential observations
#Cut off point is 4/(n-k-2)
cutoff <- 4/((nrow(puma_data)-length(model_4$coefficients)-2))

#Calculate Cook's distance
cook.d <- cooks.distance(model_4)
```

```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
#Plot to identify observation with Cook's distance higher than cutoff
plot(cook.d, pch=".", cex=2, main="Influential Obs by Cooks distance")  # plot cook's distance
abline(h = cutoff, col="red")  # add cutoff line
text(x=1:length(cook.d)+1, y=cook.d, labels=ifelse(cook.d>cutoff, names(cook.d),""), col="red")  # add labels
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
# Removing Outliers
# influential row numbers
influential <- as.numeric(names(cook.d)[(cook.d > cutoff)])

#Create another data frame without influential observations
puma_data_2 <- puma_data[-influential, ]

#Fit a regression without influential
model_5 <- lm(log(Income) ~ EducationGroup + Sex * Age, data = puma_data_2, na.action = na.exclude)

#Compare the summary before and after removing outliers
summary(model_4)
summary(model_5)
```

```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
par(mfrow=c(2,2))
#Linear regression assumption
plot(fitted(model_5), residuals(model_5))

#Normality assumption
qqnorm(residuals(model_5))
qqline(residuals(model_5))

#Independence assumptions
plot(residuals(model_5))


```
```{r,  error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Multi-colinearlity
vif(model_5)
```

```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
#Fit ridge regression
x <- model.matrix(log(Income) ~ EducationGroup + Sex * Age, puma_data_2)[, -1]
y <- log(puma_data_2$Income)

ridge_model <- glmnet(x, y, alpha = 0)


summary(ridge_model)

#perform 10 fold cross-validation to find optimal lambda value
cv_model <- cv.glmnet(x, y, alpha = 0)

#find optimal lambda value that minimizes test MSE
best_lambda <- cv_model$lambda.min
best_lambda

#produce plot of test MSE by lambda value
plot(cv_model) 

#The lambda value that minimizes the test MSE turns out to be 0.04258514

#find coefficients of model with best lambda
model_6 <- glmnet(x, y, alpha = 0, lambda = best_lambda)
coef(model_6)

#produce Ridge trace plot
plot(ridge_model, xvar = "lambda")
```
The model that will be used to address the question:

$$log(Income) = 9.436 + 0.379(HS, GED, or Associates Degree) +$$ 
$$ 1(Bachelors Degree) + 1.323(Masters Degree or higher) + $$
$$0.232(Male) + 0.002(Age) + 0.003(Male:Age)$$

# Interpret the data

To answer our question, does higher education mean higher income accounting for sex and age? Use the fitted model to compare the income across all 4 levels of education for a 50 years old (mean and median of the dataset) for males and females in Oregon.

```{r,  error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Calculate median income for 50 YO males
coef <- coef(model_6)
lw_HS_m  <- coef[1, ] + coef[5, ] + (50*coef[6, ]) + (50*1*coef[7, ]) #lower than HS male
GED_m    <- coef[1, ] + coef[2, ] + coef[5, ] + (50*coef[6, ]) + (50*1*coef[7, ]) #HS, GED, Associate degree male
bach_m   <- coef[1, ] + coef[3, ] + coef[5, ] + (50*coef[6, ]) + (50*1*coef[7, ]) #Bachelor's degree male
master_m <- coef[1, ] + coef[4, ] + coef[5, ] + (50*coef[6, ]) + (50*1*coef[7, ]) #master or higher male

exp(lw_HS_m)
exp(GED_m)
exp(bach_m)
exp(master_m)

#Calculate median income for 50 YO females

lw_HS_f  <- coef[1, ] + (50*coef[6, ]) #lower than HS female
GED_f    <- coef[1, ] + coef[2, ] + (50*coef[6, ]) #HS, GED, Associate degree female
bach_f   <- coef[1, ] + coef[3, ] + (50*coef[6, ]) #Bachelor's degree female
master_f <- coef[1, ] + coef[4, ] + (50*coef[6, ]) #master or higher female

exp(lw_HS_f)
exp(GED_f)
exp(bach_f)
exp(master_f)
```

The median income for 50-year-old males in Oregon varies significantly across different educational categories. For individuals with less than a high school education, their income is \$21,273.80, slightly lower than those with a high school diploma, GED, or associate degree at \$31,089.90. Individuals with a bachelor's degree see a notable increase in an income to \$57,829.09 and $79,867.54 for those with a master's degree or higher.

Similarly, for 50-year-old females in Oregon, a comparable pattern was observed. For individuals with less than a high school education, their income is \$14,136.47, slightly increasing for those with a high school diploma, GED, or associate degree to \$20,659.28. As observed in males, there is a significant increase in an income for females with a bachelor's degree, reaching $38,427.51, and continuing to rise with higher educational attainment to \$53,072.1 when they hold a master's degree or higher.

There is a clear relationship between educational attainment and income for both 50-year-old males and females in Oregon. Individuals with higher levels of education tend to have higher median incomes, with notable increases observed at certain educational milestones, such as obtaining bachelor's degree and above.


## Second Question
Can we predict household income based on education, occupation, and race/ethnicity?

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
puma_data_q2 <- puma_data |>
  select(EducationGroup, Income, Race, OccupationGroup)
head(puma_data_q2)
```


```{r,  error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
summary(puma_data_q2)
```

```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
#Data visualization
puma_data_q2_race_income <- puma_data_q2 |>
  group_by(Race, Income) |>
  summarise(n = n())

ggplot(puma_data_q2_race_income, aes(x = Income)) +
  geom_histogram(binwidth = 5000, fill = "skyblue", color = "black") +
  facet_wrap(~Race) +
  labs(title = "Distribution of Income by Race", x = "Income", y = "Frequency")
```


```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
#Data visualization
puma_data_q2_occ_income <- puma_data_q2 |>
  group_by(OccupationGroup, Income) |>
  summarise(n = n())

ggplot(puma_data_q2_occ_income, aes(x = Income)) +
  geom_histogram(binwidth = 5000, fill = "skyblue", color = "black") +
  facet_wrap(~OccupationGroup) +
  labs(title = "Distribution of Income by Occupation Group and Race", x = "Income", y = "Frequency")

```

## Model Selection


We explored the predictive power of EducationGroup, OccupationGroup, and Race in forecasting household income through the Validation-Set Approach and Cross-Validation. Initially, we separated our dataset into training and testing sets. Employing best subset selection exclusively on the training data, we determined the most effective model for each model size, assessing the validation set error accordingly. Consequently, the model that includes nine variables identified as the most optimal. This process was then replicated on the entire dataset, confirming that the best nine-variable model from the training data are identical to the full dataset.

Furthermore, we utilized cross-validation to choose models of varying sizes. 10-fold cross-validation was deployed and resulted in the selection of an eleven-variable model, which are all variables present in the dataset. Therefore, we performed best subset selection on the full data set in order to obtain the 11-variable model, we obtained all variables. The plot below shows that the model with 11 variables has the least mean square error.


```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Validation set and CV
#Separate data into 2 groups, training and testing data
set.seed(538)
train <- sample(c(TRUE, FALSE), nrow(puma_data_q2), replace = TRUE)
test <- (!train)


#apply regsubsets() to the training set in order to perform best subset selection
regfit.best <- regsubsets(Income ~ ., data = puma_data_q2[train, ], nvmax = 11)

#make a model matrix from the test data
test.mat <- model.matrix(Income ~ ., data = puma_data_q2[test, ]) 

#run a loop, and for each size i
val.errors <- rep(NA, 11) 

for (i in 1:11) {
coefi <- coef(regfit.best, id = i)
pred  <- test.mat[, names(coefi)] %*% coefi 
val.errors[i] <- mean((puma_data_q2$Income[test] - pred)^2)
}

#Show MSE
val.errors
which.min(val.errors)
coef(regfit.best, 9)

#perform best subset selection on the full data set, and select the best 9 variable model
regfit.best <- regsubsets(Income ~ ., data = puma_data_q2, nvmax =11)
coef(regfit.best, 9)
```

```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
k <- 10
n <- nrow(puma_data_q2)
set.seed(1)
folds <- sample(rep(1:k, length = n)) 
cv.errors <- matrix(NA, k, 11, 
                    dimnames = list(NULL, paste(1:11)))


#Create predict function
predict.regsubsets <- function(object, newdata, id, ...) { 
form <- as.formula(object$call[[2]])
mat <- model.matrix(form, newdata)
coefi <- coef(object, id = id)
xvars <- names(coefi) 
mat[, xvars] %*% coefi
}


for (j in 1:k) {
best.fit <- regsubsets(Income ~ .,
data = puma_data_q2[folds != j, ],
nvmax = 11) 
for (i in 1:11) {
pred <- predict(best.fit, puma_data_q2[folds == j, ], id = i) 
cv.errors[j, i] <- mean((puma_data_q2$Income[folds == j] - pred)^2) }
}


mean.cv.errors <- apply(cv.errors, 2, mean) 
mean.cv.errors

par(mfrow = c(1, 1))
plot(mean.cv.errors, type = "b")
```


```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Cross-validation selects a 11-variable model
#perform best subset selection on the full data set in order to obtain the 11-variable model
#11 variables includes all variables in the dataset
reg.best <- regsubsets(Income ~ ., data = puma_data_q2, nvmax = 11)
coef(reg.best, 11)
```
## Intrepret the data

In this question, we wants to know if we can predict household income based on education, occupation, and race/ethnicity? In conclusion, our validation set and cross-validation analyses strongly indicate that EducationGroup, Race, and OccupationGroup are significant predictors of household income. These findings shed light on the key factors influencing income levels and could guide future research and policy efforts aimed at reducing income disparities.

## Third Question
Is there a relationship between Occupation, home ownership, race/ethnicity and Marial Status,  OccupationGroup, income?

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
head(puma_data_raw)
```


```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
puma_data_q3 <- puma_data_raw |>
  select(Homeownership, Race, MaritalStatus, OccupationGroup, Occupation, Income)
head(puma_data_q3)
```
```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
puma_data_filtered <- puma_data_q3 |>
  filter(Occupation != 0)


ggplot(puma_data_filtered, aes(x = Occupation)) +
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Distribution of Occupations", x = "Occupation", y = "Count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r,message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
ggplot(puma_data_q3, aes(x = OccupationGroup, y = Occupation)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "black") +
  labs(title = "The relationship between OccupationGroup and Occupation Size", x = "OccupationGroup", y = "Occupation Size") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```
```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
ggplot(puma_data_q3, aes(x = Homeownership, y = Occupation)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "black") +
  labs(title = "The relationship between Homeownership and Occupation Size", x = "Homeownership", y = "Occupation Size") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
ggplot(puma_data_q3, aes(x = Race, fill = factor(Occupation))) +
  geom_bar() +
  labs(title = "Occupation vs. Homeownership by Race", x = "Race", y = "Count of Occupations") +
  scale_fill_manual(values = c("White" = "blue", "Black" = "red")) +  # Customize colors for each race
  theme(axis.text.x = element_text(angle = 45, hjust = 1))



```

## Model selection

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
model_1_q3 <- lm(Occupation ~ as.factor(MaritalStatus) + as.factor(OccupationGroup) 
      + as.factor(Homeownership) + as.factor(Race) + Income, data = puma_data_q3)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
summary(model_1_q3)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
model_2_q3 <- lm(Occupation ~ as.factor(MaritalStatus) + as.factor(OccupationGroup) 
      + as.factor(Homeownership) + Income, data = puma_data_q3)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
summary(model_2_q3)
```
```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
#Compare models 1 and model 2
anova(model_1_q3, model_2_q3)
```

From the result, we can see that Model 1 has a lower residual sum of squares 
(RSS) compared to Model 2, indicating that it fits the data better.
The F-statistic for the comparison between Model 1 and Model 2 is 5.4446, with 
a very low p-value (6.915e-07), indicating that the additional predictors in 
Model 1 significantly improve the fit of the model.
Based on this information, we can conclude that Model 1 performs better than Model 2. 
The additional predictors in Model 1 (Race) significantly improve the model's 
ability to explain the variation in the occupation variable compared to Model 2.


```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}

plot(fitted(model_1_q3), residuals(model_1_q3))


qqnorm(residuals(model_1_q3))
qqline(residuals(model_1_q3))


plot(residuals(model_1_q3))

#Fitted vs residuals plot exhibiting pattern
```


```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
model_3_q3 <- lm(Occupation ~ as.factor(MaritalStatus) * as.factor(OccupationGroup) 
      + as.factor(Homeownership) + as.factor(Race) + Income, data = puma_data_q3)

```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
model_4_q3 <- lm(Occupation ~ as.factor(MaritalStatus) + as.factor(OccupationGroup) 
      * as.factor(Homeownership) + as.factor(Race) + Income, data = puma_data_q3)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
summary(model_3_q3)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
summary(model_4_q3)
```

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
anova(model_3_q3, model_4_q3)
```

Model 3 has a lower residual sum of squares (RSS) compared to Model 4, indicating 
a better fit to the data. Since Model 1 has a lower RSS with the same degrees of freedom as Model 2, we can conclude that Model 3 performs better in terms of model fit.
Therefore, based on the information provided, Model 3 is better than Model 4.

```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}
plot(fitted(model_3_q3), residuals(model_3_q3))


qqnorm(residuals(model_3_q3))
qqline(residuals(model_3_q3))


plot(residuals(model_3_q3))

#Fitted vs residuals plot exhibiting pattern
```
## Model interpretation


```{r, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide'}

summary(model_1_q3)$coefficients
summary(model_1_q3)$r.squared
plot(model_1_q3)
```
Answer:
From the model, we get the formula:


$$Occupation=3.779623 \times Intercept
-5.682494 \times Married + 5.002508 \times Not Married/Under 15$$
$$-69.46579 \times Separated
-23.86628 \times Widowed
+5092.785 \times Manufacturing/Transportation$$
$$+5967.028 \times Military
-2301.276 \times Professional/Technical
+1500.935 \times WhiteCollar/BlueCollar$$
$$-86.83271 \times Occupied without payment of rent
+31.75971 \times Owned free and clear
+13.18805 \times Owned with mortgage or loan$$
$$+10.9471 \times Rented
+41.31494 \times Black/African American
+91.19606 \times Native American/Alaskan$$
$$+113.0133 \times Other/MoreThanOne
+112.7199 \times White
-0.0008919726 \times Income$$

```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
train_index <- sample(1:nrow(puma_data_q3), 0.8 * nrow(puma_data_q3))  # 80% for training
train_data <- puma_data_q3[train_index, ]
test_data <- puma_data_q3[-train_index, ]

```


```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}
num_folds <- 10

model_1_q3 <- lm(Occupation ~ as.factor(MaritalStatus) + as.factor(OccupationGroup) 
      + as.factor(Homeownership) + as.factor(Race) + Income, data = puma_data_q3)

test_rmse <- numeric(num_folds)
test_mae <- numeric(num_folds)


for (i in 1:num_folds) {

  train_index <- sample(1:nrow(puma_data_q3), 0.8 * nrow(puma_data_q3))  # 80% for training
  train_data <- puma_data_q3[train_index, ]
  test_data <- puma_data_q3[-train_index, ]
  

  model_1 <- lm(Occupation ~ as.factor(MaritalStatus) + as.factor(OccupationGroup) 
      + as.factor(Homeownership) + as.factor(Race) + Income, data = train_data)
  

  predictions <- predict(model_1, newdata = test_data)
  

  test_rmse[i] <- sqrt(mean((test_data$Occupation - predictions)^2))
  test_mae[i] <- mean(abs(test_data$Occupation - predictions))
}


avg_test_rmse <- mean(test_rmse)
avg_test_mae <- mean(test_mae)

# Print average test set performance
cat("Average Test RMSE:", avg_test_rmse, "\n")
cat("Average Test MAE:", avg_test_mae, "\n")


```
```{r, error=TRUE, collapse=TRUE, warning=FALSE, echo=FALSE, results='hide'}

test_rmse <- numeric(num_folds)
test_mae <- numeric(num_folds)


for (i in 1:num_folds) {

  train_index <- sample(1:nrow(puma_data_q3), 0.8 * nrow(puma_data_q3))  # 80% for training
  train_data <- puma_data_q3[train_index, ]
  test_data <- puma_data_q3[-train_index, ]
  

  model_3 <- lm(Occupation ~ as.factor(MaritalStatus) * as.factor(OccupationGroup) 
      + as.factor(Homeownership) + as.factor(Race) + Income, data = puma_data_q3)
  

  predictions <- predict(model_3, newdata = test_data)
  

  test_rmse[i] <- sqrt(mean((test_data$Occupation - predictions)^2))
  test_mae[i] <- mean(abs(test_data$Occupation - predictions))
}


avg_test_rmse <- mean(test_rmse)
avg_test_mae <- mean(test_mae)

# Print average test set performance
cat("Average Test RMSE:", avg_test_rmse, "\n")
cat("Average Test MAE:", avg_test_mae, "\n")
```

#Obstacles

* Git collaboration: At the beginning, each team member is using the main branch to commit changes without validating other peopleâ€™s changes. Then we decided to use the personal branch first and the other team members validated before merging into the main. However, when we worked together and kept pushing into the main, there was code code conflict. We review the conflict and use the git command to resolve the conflict.
* Future work/improvement: For our team data, in the categorical variable, there are too many categories. It causes our R notebook compute time to be too long and hard to interpret the result when we have so many categories. In the future, when we do data cleaning, there should be fewer categories in each variable.


## Appendix

```{r, eval = FALSE, warning=FALSE, fig.show='hide'}
## An if statement for checking if a package is installed :)
#if(!require(somepackage)){
#    install.packages("somepackage")
#    library(somepackage)
#}

if (!require(tidycensus)) {
  install.packages("tidycensus")
}
if (!require(tidyverse)) {
  install.packages("tidyverse")
}
if (!require(dplyr)) {
  install.packages("dplyr")
}
if (!require(ggplot2)) {
  install.packages("ggplot2")
}
if (!require(faraway)) {
  install.packages("faraway")
}
if (!require(car)) {
  install.packages("car")
}
if (!require(gridExtra)) {
  install.packages("gridExtra")
}
if (!require(glmnet)) {
  install.packages("glmnet")
}
if (!require(ISLR2)) {
  install.packages("ISLR2")
}
if (!require(leaps)) {
  install.packages("leaps")
}

#Load libraries
library(tidycensus)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(faraway)
library(car)
library(gridExtra)
library(glmnet)
library(ISLR2)
library(leaps)

census_api_key("2547c95ce33b1ed0eec3aafd0fd8526a5bb9a22e")

### Obtain the Data

#Pull data set for specific variables
puma_data <- get_pums(variables = c("AGEP","SCHL","PINCP", "SEX", "RAC1P", "TEN", "OCCP", "MAR", "ACR")
                      ,state = "OR"
                      ,year = 2022)

#Rename the columns
puma_data <- puma_data %>% dplyr::rename(Age = AGEP,
                                  EducationLevel = SCHL,
                                  Income = PINCP,
                                  Sex = SEX,
                                  PersonNumber = SPORDER,
                                  Race = RAC1P,
                                  Homeownership = TEN,
                                  Occupation = OCCP,
                                  MaritalStatus = MAR,
                                  HouseAcreage = ACR
                                  )
head(puma_data[, 2:8])

#Remove columns that are not needed
puma_data <- puma_data %>% 
  select(-ST, -SERIALNO, -WGTP, -PWGTP)
head(puma_data)

#Convert education levels
puma_data <- puma_data %>%
  mutate(
    EducationLevel = case_when(
      EducationLevel == "bb" ~ "00",
      TRUE ~ EducationLevel
    ),
    EducationLevel = as.numeric(EducationLevel)
  )

#Make sure it is numeric
class(puma_data$EducationLevel)

##Group education level
puma_data <- puma_data %>%
  mutate(
     EducationGroup = cut(EducationLevel, breaks = c(0, 2, 11, 16, 20, 21, 22, 24, Inf),
                         labels = c("No schooling completed", "Less than High School",
                                    "High School", "high school diploma or GED",
                                    "Associates Degree", "Bachelors Degree",
                                    "Masters Degree", "Doctorate Degree"),
                         right = FALSE)
  )
unique(puma_data$EducationGroup)
puma_data[1:50,]

#Rearrange the columns
puma_data <- puma_data %>%
  select(EducationGroup, EducationLevel, Income, Age, Sex, PersonNumber)
head(puma_data)

#Drop age below 14
puma_data <- puma_data %>%
  filter(Age >= 14)
head(puma_data[puma_data$Age < 14,])

#Identify gender
puma_data <- puma_data %>%
  mutate(
    Sex = case_when(
      Sex == 1 ~ "Male",
      Sex == 2 ~ "Female",
      TRUE ~ as.character(Sex)
    )
)
head(puma_data)

#Convert education levels
puma_data <- puma_data %>%
  mutate(
    EducationLevel = case_when(
      EducationLevel == "bb" ~ "00",
      TRUE ~ EducationLevel
    ),
    EducationLevel = as.numeric(EducationLevel)
  )

#Make sure it is numeric
class(puma_data$EducationLevel)

#Convert Occupation to numerical
puma_data <- puma_data %>%
  mutate(
    Occupation = case_when(
      Occupation == "bbbb" ~ "0000",
      Occupation == "000N" ~ "0000",
      TRUE ~ Occupation
    ),
    Occupation = as.numeric(Occupation)
  )

#Make sure it is numeric
class(puma_data$Occupation)

#Convert homeownership
puma_data <- puma_data %>%
  mutate(
    Homeownership = case_when(
      Homeownership == "b" ~ "0",
      TRUE ~ Homeownership
    ),
    Homeownership = as.numeric(Homeownership)
  )

#Make sure it is numeric
class(puma_data$Homeownership)

#Convert HouseAcreage
puma_data <- puma_data %>%
  mutate(
    HouseAcreage = case_when(
      HouseAcreage == "b" ~ "0",
      TRUE ~ HouseAcreage
    ),
    HouseAcreage = as.numeric(HouseAcreage)
  )

#Make sure it is numeric
class(puma_data$HouseAcreage)

##Group education level
puma_data <- puma_data %>%
  mutate(
     EducationGroup = cut(EducationLevel, breaks = c(0, 16, 21, 22, Inf),
                         labels = c("Less than HS", "HS, GED, or Associates Degree",
                                    "Bachelors Degree", "Masters Degree or higher"),
                         right = FALSE)
  )
unique(puma_data$EducationGroup)
puma_data[1:50,]

#Drop age below 14
puma_data <- puma_data %>%
  filter(Age >= 14)
head(puma_data[puma_data$Age < 14,])


#Drop income that are less than 1 from the data set
#Drop observation with 0 and negative income
puma_data <- puma_data %>% filter(Income >= 1)
head(puma_data)
sum(puma_data$Income<1)

#relabeling race
puma_data$Race <- as.numeric(puma_data$Race)

puma_data <- puma_data %>%
  mutate(
    Race = case_when(
      Race == 1 ~ "White",
      Race == 2 ~ "Black/AfricanAmerican",
      between(as.numeric(Race), 3, 6) ~ "NativeAmerican/Alaskan",
      between(as.numeric(Race), 6, 7) ~ "Asian/PacificIslander",
      between(as.numeric(Race), 8, 9) ~ "Other/MoreThanOne",
      TRUE ~ as.character(Race)
    )
)
puma_data$Race[1:100]

#relabeling MaritalStatus
puma_data <- puma_data %>%
  mutate(
    MaritalStatus = case_when(
      MaritalStatus == "1" ~ "Married",
      MaritalStatus == "2" ~ "Widowed",
      MaritalStatus == "3" ~ "Divorced",
      MaritalStatus == "4" ~ "Separated",
      MaritalStatus == "5" ~ "Not Married/Under 15",
      TRUE ~ as.character(MaritalStatus)
    )
)

#Checking labels are assigned.
unique(puma_data$MaritalStatus)
puma_data$MaritalStatus[11200:11300]

#relabeling Acreage
puma_data <- puma_data %>%
  mutate(
    HouseAcreage = case_when(
      HouseAcreage == 0 ~ "Not a one-family home",
      HouseAcreage == 1 ~ "< 1 Acre",
      HouseAcreage == 2 ~ "1 - 10 Acres",
      HouseAcreage == 3 ~ "> 10 Acres",
      TRUE ~ as.character(HouseAcreage)
    )
)

#Checking labels are assigned.
unique(puma_data$HouseAcreage)
puma_data$HouseAcreage[1500:1600]

#relabeling tenure
puma_data <- puma_data %>%
  mutate(
    Homeownership = case_when(
      Homeownership == 0 ~ "N/A",
      Homeownership == 1 ~ "Owned with mortgage or loan",
      Homeownership == 2 ~ "Owned free and clear",
      Homeownership == 3 ~ "Rented",
      Homeownership == 4 ~ "Occupied without payment of rent",
      TRUE ~ as.character(Homeownership)
    )
)

#Checking labels are assigned.
unique(puma_data$Homeownership)
puma_data$Homeownership[11200:11300]

#Identify gender
puma_data <- puma_data %>%
  mutate(
    Sex = case_when(
      Sex == 1 ~ "Male",
      Sex == 2 ~ "Female",
      TRUE ~ as.character(Sex)
    )
)

#Checking labels are assigned.
unique(puma_data$Sex)
head(puma_data$Sex)

#Occupation Grouping
puma_data <- puma_data %>%
  filter(as.numeric(Occupation) >= 0010 & as.numeric(Occupation) < 9920) %>%
  mutate(
    OccupationGroup = case_when(
      between(as.numeric(Occupation), 0010, 3550) ~ "Professional/Technical",
      between(as.numeric(Occupation), 3600, 4160) ~ "Healthcare/FoodServices",
      between(as.numeric(Occupation), 4200, 7640) ~ "WhiteCollar/BlueCollar",
      between(as.numeric(Occupation), 7700, 9760) ~ "Manufacturing/Transportation",
      between(as.numeric(Occupation), 9800, 9830) ~ "Military",
      TRUE ~ "Not Classified"
    )
  )

#Checking labels are assigned.
unique(puma_data$OccupationGroup)
puma_data$OccupationGroup[2020:2120]
puma_data$Occupation[puma_data$OccupationGroup == "Not Classified"]

puma_data_raw <- puma_data
head(puma_data_raw)

#Rearrange the columns
puma_data <- puma_data %>%
  select(EducationGroup, EducationLevel, OccupationGroup, Occupation, Income, Age, Sex, Race, Homeownership, PersonNumber)
head(puma_data)

## Explore the data

#Summarizing the ranges of numerical 
summary(puma_data$Age) #Range of Age
summary(puma_data$Income) #Range of Age
summary(puma_data$EducationLevel) #Range of Education
table(puma_data$EducationGroup) #Count of each level of education
table(puma_data$Race) #Count of each race
table(puma_data$Homeownership) #Count of each Homeownership
table(puma_data$OccupationGroup) #Count of each Occupationgroup

#Plot income distribution
ggplot(puma_data %>% filter(Income > 0), aes(Income)) +
  geom_histogram(binwidth = 10000) +
  scale_x_continuous(labels = function(x) paste0(x / 1000, "K")) +
  labs(title = "Income Distribution in Oregon"
       , x = "Income by $10k"
       , y = "Count of Individuals") +
  theme_minimal()
  
## Model the data

# Does higher education mean higher income accounting for sex and age?
model_1 <- lm(Income ~ EducationGroup + Sex + Age, data = puma_data)
model_2 <- lm(Income ~ EducationGroup + Sex * Age, data = puma_data)

#Compare model 1 and 2
anova(model_1, model_2)

#The full model provides a significantly better fit.

#Linearity and Homoscedasticity assumption
plot(fitted(model_2), residuals(model_2))

#Normality assumption
qqnorm(residuals(model_2))
qqline(residuals(model_2))

#Independence assumptions
plot(residuals(model_2))

#Fitted vs residuals plot exhibiting pattern

#Logged models
model_3 <- lm(log(Income) ~ EducationGroup + Sex + Age, data = puma_data, na.action = na.exclude)
model_4 <- lm(log(Income) ~ EducationGroup + Sex * Age, data = puma_data, na.action = na.exclude)

#Compare models 3 and 4
anova(model_3, model_4)

#Model 4 is the best from 2 models

#Linear regression assumption
plot(fitted(model_4), residuals(model_4))

#Normality assumption
qqnorm(residuals(model_4))
qqline(residuals(model_4))

#Independence assumptions
plot(residuals(model_4))

#Add observation ID
puma_data$ID <- 1:nrow(puma_data)

## Attaching the Case Influence Statistics with the Data
Data <- fortify(model_4, puma_data)

## Plot the Case Influence Statistics for each observation (subject)
par(mfrow=c(1,3))
qplot(ID,.hat, data = Data)
qplot(ID,.stdresid, data = Data)
qplot(ID,.cooksd, data = Data)

#There is evidence of outliers

#Test for influential observations
#Cut off point is 4/(n-k-2)
cutoff <- 4/((nrow(puma_data)-length(model_4$coefficients)-2))

#Calculate Cook's distance
cook.d <- cooks.distance(model_4)

#Plot to identify observation with Cook's distance higher than cutoff
plot(cook.d, pch=".", cex=2, main="Influential Obs by Cooks distance")  # plot cook's distance
abline(h = cutoff, col="red")  # add cutoff line
text(x=1:length(cook.d)+1, y=cook.d, labels=ifelse(cook.d>cutoff, names(cook.d),""), col="red")  # add labels

# Removing Outliers
# influential row numbers
influential <- as.numeric(names(cook.d)[(cook.d > cutoff)])

#Create another data frame without influential observations
puma_data_2 <- puma_data[-influential, ]

#Fit a regression without influential
model_5 <- lm(log(Income) ~ EducationGroup + Sex * Age, data = puma_data_2, na.action = na.exclude)

#Compare the summary before and after removing outliers
summary(model_4)
summary(model_5)

par(mfrow=c(2,2))
#Linear regression assumption
plot(fitted(model_5), residuals(model_5))

#Normality assumption
qqnorm(residuals(model_5))
qqline(residuals(model_5))

#Independence assumptions
plot(residuals(model_5))

#Multi-colinearlity
vif(model_5)

#Fit ridge regression
x <- model.matrix(log(Income) ~ EducationGroup + Sex * Age, puma_data_2)[, -1]
y <- log(puma_data_2$Income)

ridge_model <- glmnet(x, y, alpha = 0)


summary(ridge_model)

#perform 10 fold cross-validation to find optimal lambda value
cv_model <- cv.glmnet(x, y, alpha = 0)

#find optimal lambda value that minimizes test MSE
best_lambda <- cv_model$lambda.min
best_lambda

#produce plot of test MSE by lambda value
plot(cv_model) 

#The lambda value that minimizes the test MSE turns out to be 0.04258514

#find coefficients of model with best lambda
model_6 <- glmnet(x, y, alpha = 0, lambda = best_lambda)
coef(model_6)

#produce Ridge trace plot
plot(ridge_model, xvar = "lambda")

## Interpret the data

#Calculate median income for 50 YO males
coef <- coef(model_6)
lw_HS_m  <- coef[1, ] + coef[5, ] + (50*coef[6, ]) + (50*1*coef[7, ]) #lower than HS male
GED_m    <- coef[1, ] + coef[2, ] + coef[5, ] + (50*coef[6, ]) + (50*1*coef[7, ]) #HS, GED, Associate degree male
bach_m   <- coef[1, ] + coef[3, ] + coef[5, ] + (50*coef[6, ]) + (50*1*coef[7, ]) #Bachelor's degree male
master_m <- coef[1, ] + coef[4, ] + coef[5, ] + (50*coef[6, ]) + (50*1*coef[7, ]) #master or higher male

exp(lw_HS_m)
exp(GED_m)
exp(bach_m)
exp(master_m)

#Calculate median income for 50 YO females

lw_HS_f  <- coef[1, ] + (50*coef[6, ]) #lower than HS female
GED_f    <- coef[1, ] + coef[2, ] + (50*coef[6, ]) #HS, GED, Associate degree female
bach_f   <- coef[1, ] + coef[3, ] + (50*coef[6, ]) #Bachelor's degree female
master_f <- coef[1, ] + coef[4, ] + (50*coef[6, ]) #master or higher female

exp(lw_HS_f)
exp(GED_f)
exp(bach_f)
exp(master_f)

### Second Question

# Can we predict household income based on education, occupation, and race/ethnicity?
head(puma_data)

puma_data_q2 <- puma_data |>
  select(EducationGroup, Income, Race, OccupationGroup)
head(puma_data_q2)

summary(puma_data_q2)

#Data visualization
puma_data_q2_race_income <- puma_data_q2 |>
  group_by(Race, Income) |>
  summarise(n = n())

ggplot(puma_data_q2_race_income, aes(x = Income)) +
  geom_histogram(binwidth = 5000, fill = "skyblue", color = "black") +
  facet_wrap(~Race) +
  labs(title = "Distribution of Income by Race", x = "Income", y = "Frequency")
  
#Data visualization
puma_data_q2_occ_income <- puma_data_q2 |>
  group_by(OccupationGroup, Income) |>
  summarise(n = n())

ggplot(puma_data_q2_occ_income, aes(x = Income)) +
  geom_histogram(binwidth = 5000, fill = "skyblue", color = "black") +
  facet_wrap(~OccupationGroup) +
  labs(title = "Distribution of Income by Occupation Group and Race", x = "Income", y = "Frequency")
  
## Model Selection
#Validation set and CV
#Separate data into 2 groups, training and testing data
set.seed(538)
train <- sample(c(TRUE, FALSE), nrow(puma_data_q2), replace = TRUE)
test <- (!train)


#apply regsubsets() to the training set in order to perform best subset selection
regfit.best <- regsubsets(Income ~ ., data = puma_data_q2[train, ], nvmax = 11)

#make a model matrix from the test data
test.mat <- model.matrix(Income ~ ., data = puma_data_q2[test, ]) 

#run a loop, and for each size i
val.errors <- rep(NA, 11) 

for (i in 1:11) {
coefi <- coef(regfit.best, id = i)
pred  <- test.mat[, names(coefi)] %*% coefi 
val.errors[i] <- mean((puma_data_q2$Income[test] - pred)^2)
}

#Show MSE
val.errors
which.min(val.errors)
coef(regfit.best, 9)

#perform best subset selection on the full data set, and select the best 9 variable model
regfit.best <- regsubsets(Income ~ ., data = puma_data_q2, nvmax =11)
coef(regfit.best, 9)

k <- 10
n <- nrow(puma_data_q2)
set.seed(1)
folds <- sample(rep(1:k, length = n)) 
cv.errors <- matrix(NA, k, 11, 
                    dimnames = list(NULL, paste(1:11)))


#Create predict function
predict.regsubsets <- function(object, newdata, id, ...) { 
form <- as.formula(object$call[[2]])
mat <- model.matrix(form, newdata)
coefi <- coef(object, id = id)
xvars <- names(coefi) 
mat[, xvars] %*% coefi
}


for (j in 1:k) {
best.fit <- regsubsets(Income ~ .,
data = puma_data_q2[folds != j, ],
nvmax = 11) 
for (i in 1:11) {
pred <- predict(best.fit, puma_data_q2[folds == j, ], id = i) 
cv.errors[j, i] <- mean((puma_data_q2$Income[folds == j] - pred)^2) }
}


mean.cv.errors <- apply(cv.errors, 2, mean) 
mean.cv.errors

par(mfrow = c(1, 1))
plot(mean.cv.errors, type = "b")

#Cross-validation selects a 11-variable model
#perform best subset selection on the full data set in order to obtain the 11-variable model
#11 variables includes all variables in the dataset
reg.best <- regsubsets(Income ~ ., data = puma_data_q2, nvmax = 11)
coef(reg.best, 11)

## Intrepret the data

### Third Question
# Is there a relationship between Occupation, home ownership, race/ethnicity and Marial Status,  OccupationGroup, income?
head(puma_data_raw)

puma_data_q3 <- puma_data_raw |>
  select(Homeownership, Race, MaritalStatus, OccupationGroup, Occupation, Income)
head(puma_data_q3)
```